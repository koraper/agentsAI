---
name: postgresql-table-design
description: 설계 a PostgreSQL-특정 스키마. Covers 최선의-관행, 데이터 유형, 색인, constraints, 성능 패턴, 및 고급 기능
---

# PostgreSQL 테이블 설계 

## 핵심 규칙

- Define a **PRIMARY 키** 위한 참조 테이블 (사용자, 정렬합니다, etc.). Not 항상 필요한 위한 시간-시리즈/이벤트/log 데이터. 때 used, prefer `BIGINT GENERATED ALWAYS AS IDENTITY`; use `UUID` 오직 때 전역 uniqueness/opacity is 필요한.
- **Normalize 첫 번째 (에 3NF)** 에 eliminate 데이터 redundancy 및 업데이트 anomalies; denormalize **오직** 위한 측정된, high-ROI 읽습니다 곳 join 성능 is 입증된 problematic. Premature denormalization 생성합니다 유지보수 burden.
- Add **NOT NULL** everywhere it’s semantically 필수; use **default**s 위한 일반적인 값.
- Create **인덱스 위한 access 경로 you actually 쿼리**: PK/고유한 (auto), **FK 열 (manual!)**, frequent 필터링합니다/정렬합니다, 및 join 키.
- Prefer **TIMESTAMPTZ** 위한 이벤트 시간; **NUMERIC** 위한 money; **TEXT** 위한 strings; **BIGINT** 위한 정수 값, **DOUBLE 정밀도** 위한 floats (또는 `NUMERIC` 위한 exact 십진수 arithmetic).

## PostgreSQL “Gotchas”

- **Identifiers**: unquoted → lowercased. Avoid quoted/혼합된-case names. 규약: use `snake_case` 위한 테이블/열 names.
- **고유한 + NULLs**: 고유한 허용합니다 여러 NULLs. Use `UNIQUE (...) NULLS NOT DISTINCT` (PG15+) 에 restrict 에 one NULL.
- **FK 인덱스**: PostgreSQL **does not** auto-인덱스 FK 열. Add them.
- **아니요 silent coercions**: length/정밀도 overflows 오류 out (아니요 truncation). 예제: inserting 999 into `NUMERIC(2,0)` fails 와 함께 오류, unlike 일부 databases 것 silently truncate 또는 round.
- **순서를 정합니다/아이덴티티 have gaps** (정상; don't "fix"). Rollbacks, crashes, 및 concurrent transactions create gaps 에서 ID 순서를 정합니다 (1, 2, 5, 6...). This is 예상되는 behavior—don't try 에 make IDs consecutive.
- **힙 스토리지**: 아니요 클러스터링됨 PK 에 의해 default (unlike SQL 서버/MySQL InnoDB); `CLUSTER` is one-꺼짐 reorganization, not 유지됨 에 subsequent inserts. 행 순서 에 디스크 is insertion 순서 하지 않는 한 명시적으로 클러스터링됨.
- **MVCC**: 업데이트합니다/deletes leave dead 튜플; vacuum 처리합니다 them—설계 에 avoid hot 넓은-행 churn.

## 데이터 유형

- **IDs**: `BIGINT GENERATED ALWAYS AS IDENTITY` 선호됨 (`GENERATED BY DEFAULT` 또한 세밀한); `UUID` 때 병합하는/federating/used 에서 a 분산 시스템 또는 위한 opaque IDs. Generate 와 함께 `uuidv7()` (선호됨 만약 사용하여 PG18+) 또는 `gen_random_uuid()` (만약 사용하여 an older PG 버전).
- **Integers**: prefer `BIGINT` 하지 않는 한 스토리지 공간 is 긴급; `INTEGER` 위한 smaller ranges; avoid `SMALLINT` 하지 않는 한 제약된.
- **Floats**: prefer `DOUBLE PRECISION` over `REAL` 하지 않는 한 스토리지 공간 is 긴급. Use `NUMERIC` 위한 exact 십진수 arithmetic.
- **Strings**: prefer `TEXT`; 만약 length 제한합니다 필요한, use `CHECK (LENGTH(col) <= n)` instead of `VARCHAR(n)`; avoid `CHAR(n)`. Use `BYTEA` 위한 바이너리 데이터. Large strings/바이너리 (>2KB default threshold) automatically 저장됨 에서 TOAST 와 함께 압축. TOAST 스토리지: `PLAIN` (아니요 TOAST), `EXTENDED` (compress + out-of-line), `EXTERNAL` (out-of-line, 아니요 compress), `MAIN` (compress, keep 에서-line 만약 possible). default `EXTENDED` 일반적으로 최적. Control 와 함께 `ALTER TABLE tbl ALTER COLUMN col SET STORAGE strategy` 및 `ALTER TABLE tbl SET (toast_tuple_target = 4096)` 위한 threshold. case-insensitive: 위한 locale/accent 처리 use non-deterministic collations; 위한 plain ASCII use 표현식 인덱스 에 `LOWER(col)` (선호됨 하지 않는 한 열 needs case-insensitive PK/FK/고유한) 또는 `CITEXT`.
- **Money**: `NUMERIC(p,s)` (절대 ~하지 않음 부동소수점).
- **시간**: `TIMESTAMPTZ` 위한 timestamps; `DATE` 위한 날짜-오직; `INTERVAL` 위한 durations. Avoid `TIMESTAMP` (없이 timezone). Use `now()` 위한 트랜잭션 start 시간, `clock_timestamp()` 위한 현재 wall-clock 시간.
- **Booleans**: `BOOLEAN` 와 함께 `NOT NULL` 제약 하지 않는 한 tri-상태 값 are 필수.
- **Enums**: `CREATE TYPE ... AS ENUM` 위한 small, 안정적인 세트 (e.g. US states, days of week). 위한 비즈니스-logic-driven 및 evolving 값 (e.g. 순서 statuses) → use TEXT (또는 INT) + CHECK 또는 lookup 테이블.
- **배열**: `TEXT[]`, `INTEGER[]`, etc. Use 위한 정렬된 목록 곳 you 쿼리 elements. 인덱스 와 함께 **GIN** 위한 containment (`@>`, `<@`) 및 overlap (`&&`) 쿼리. Access: `arr[1]` (1-색인된), `arr[1:3]` (slicing). 좋은 위한 태그합니다, categories; avoid 위한 relations—use junction 테이블 instead. Literal 구문: `'{val1,val2}'` 또는 `ARRAY[val1,val2]`.
- **범위 유형**: `daterange`, `numrange`, `tstzrange` 위한 intervals. 지원 overlap (`&&`), containment (`@>`), operators. 인덱스 와 함께 **GiST**. 좋은 위한 예약, versioning, numeric ranges. Pick a bounds scheme 및 use it consistently; prefer `[)` (inclusive/exclusive) 에 의해 default.
- **네트워크 유형**: `INET` 위한 IP 주소, `CIDR` 위한 네트워크 ranges, `MACADDR` 위한 MAC 주소. 지원 네트워크 operators (`<<`, `>>`, `&&`).
- **Geometric 유형**: `POINT`, `LINE`, `POLYGON`, `CIRCLE` 위한 2D spatial 데이터. 인덱스 와 함께 **GiST**. Consider **PostGIS** 위한 고급 spatial 기능.
- **Text search**: `TSVECTOR` 위한 전체-text search 문서화합니다, `TSQUERY` 위한 search 쿼리. 인덱스 `tsvector` 와 함께 **GIN**. 항상 specify language: `to_tsvector('english', col)` 및 `to_tsquery('english', 'query')`. 절대 ~하지 않음 use single-인수 버전. This applies 에 둘 다 인덱스 expressions 및 쿼리.
- **도메인 유형**: `CREATE DOMAIN email AS TEXT CHECK (VALUE ~ '^[^@]+@[^@]+$')` 위한 reusable 사용자 정의 유형 와 함께 검증. Enforces constraints 전반에 걸쳐 테이블.
- **복합 유형**: `CREATE TYPE address AS (street TEXT, city TEXT, zip TEXT)` 위한 구조화된 데이터 내에 열. Access 와 함께 `(col).field` 구문.
- **JSONB**: 선호됨 over JSON; 인덱스 와 함께 **GIN**. Use 오직 위한 선택적/semi-구조화된 attrs. 오직 use JSON 만약 the original 정렬 of the 콘텐츠 MUST be 보존됨.
- **Vector 유형**: `vector` 유형 에 의해 `pgvector` 위한 vector similarity search 위한 embeddings.


### do not use the 다음 데이터 유형
- do NOT use `timestamp` (없이 시간 zone); do use `timestamptz` instead.
- do NOT use `char(n)` 또는 `varchar(n)`; do use `text` instead.
- do NOT use `money` 유형; do use `numeric` instead.
- do NOT use `timetz` 유형; do use `timestamptz` instead.
- do NOT use `timestamptz(0)` 또는 어떤 other 정밀도 사양; do use `timestamptz` instead
- do NOT use `serial` 유형; do use `generated always as identity` instead.


## 테이블 유형

- **일반**: default; 완전히 내구성, 로깅된.
- **임시**: 세션-scoped, auto-dropped, not 로깅된. Faster 위한 scratch work.
- **UNLOGGED**: 영구적 그러나 not crash-safe. Faster 씁니다; 좋은 위한 캐시합니다/staging.

## 행-레벨 Security

Enable 와 함께 `ALTER TABLE tbl ENABLE ROW LEVEL SECURITY`. Create 정책: `CREATE POLICY user_access ON orders FOR SELECT TO app_users USING (user_id = current_user_id())`. 구축된-에서 사용자-based access control 에서 the 행 레벨.

## Constraints

- **PK**: 암시적인 고유한 + NOT NULL; 생성합니다 a B-트리 인덱스.
- **FK**: specify `ON DELETE/UPDATE` action (`CASCADE`, `RESTRICT`, `SET NULL`, `SET DEFAULT`). Add 명시적인 인덱스 에 referencing 열—speeds up 결합합니다 및 방지합니다 locking 이슈 에 parent deletes/업데이트합니다. Use `DEFERRABLE INITIALLY DEFERRED` 위한 circular FK 종속성 확인된 에서 트랜잭션 end.
- **고유한**: 생성합니다 a B-트리 인덱스; 허용합니다 여러 NULLs 하지 않는 한 `NULLS NOT DISTINCT` (PG15+). 표준 behavior: `(1, NULL)` 및 `(1, NULL)` are 허용된. 와 함께 `NULLS NOT DISTINCT`: 오직 one `(1, NULL)` 허용된. Prefer `NULLS NOT DISTINCT` 하지 않는 한 you 구체적으로 need 중복 NULLs.
- **CHECK**: 행-로컬 constraints; NULL 값 pass the check (three-valued logic). 예제: `CHECK (price > 0)` 허용합니다 NULL prices. Combine 와 함께 `NOT NULL` 에 enforce: `price NUMERIC NOT NULL CHECK (price > 0)`.
- **EXCLUDE**: 방지합니다 overlapping 값 사용하여 operators. `EXCLUDE USING gist (room_id WITH =, booking_period WITH &&)` 방지합니다 double-booking rooms. 필요합니다 적절한 인덱스 유형 (자주 GiST).

## 색인

- **B-트리**: default 위한 equality/범위 쿼리 (`=`, `<`, `>`, `BETWEEN`, `ORDER BY`)
- **복합**: 순서 matters—인덱스 used 만약 equality 에 leftmost prefix (`WHERE a = ? AND b > ?` uses 인덱스 에 `(a,b)`, 그러나 `WHERE b = ?` does not). Put most selective/자주 필터링된 열 첫 번째.
- **Covering**: `CREATE INDEX ON tbl (id) INCLUDE (name, email)` - 포함합니다 non-키 열 위한 인덱스-오직 scans 없이 visiting 테이블.
- **부분**: 위한 hot subsets (`WHERE status = 'active'` → `CREATE INDEX ON tbl (user_id) WHERE status = 'active'`). 어떤 쿼리 와 함께 `status = 'active'` can use this 인덱스.
- **표현식**: 위한 계산된 search 키 (`CREATE INDEX ON tbl (LOWER(email))`). 표현식 must match 정확하게 에서 곳 clause: `WHERE LOWER(email) = 'user@example.com'`.
- **GIN**: JSONB containment/existence, 배열 (`@>`, `?`), 전체-text search (`@@`)
- **GiST**: ranges, geometry, exclusion constraints
- **BRIN**: 매우 large, naturally 정렬된 데이터 (시간-시리즈)—최소 스토리지 overhead. Effective 때 행 순서 에 디스크 correlates 와 함께 색인된 열 (insertion 순서 또는 이후 `CLUSTER`).

## 분할

- Use 위한 매우 large 테이블 (>100M 행) 곳 쿼리 consistently 필터 에 파티션 키 (자주 시간/날짜).
- Alternate use: use 위한 테이블 곳 데이터 유지보수 tasks dictates e.g. 데이터 pruned 또는 bulk 대체된 주기적으로
- **범위**: 일반적인 위한 시간-시리즈 (`PARTITION BY RANGE (created_at)`). Create 분할합니다: `CREATE TABLE logs_2024_01 PARTITION OF logs FOR VALUES FROM ('2024-01-01') TO ('2024-02-01')`. **TimescaleDB** 자동화합니다 시간-based 또는 ID-based 분할 와 함께 retention 정책 및 압축.
- **목록**: 위한 discrete 값 (`PARTITION BY LIST (region)`). 예제: `FOR VALUES IN ('us-east', 'us-west')`.
- **해시**: 위한 심지어 배포 때 아니요 natural 키 (`PARTITION BY HASH (user_id)`). 생성합니다 N 분할합니다 와 함께 modulus.
- **제약 exclusion**: 필요합니다 `CHECK` constraints 에 분할합니다 위한 쿼리 planner 에 prune. Auto-생성된 위한 declarative 분할 (PG10+).
- Prefer declarative 분할 또는 hypertables. do NOT use 테이블 inheritance.
- **Limitations**: 아니요 전역 고유한 constraints—include 파티션 키 에서 PK/고유한. FKs 에서 분할된 테이블 not 지원된; use 트리거합니다.

## Special Considerations

### 업데이트-Heavy 테이블

- **별도 hot/cold 열**—put 자주 업데이트된 열 에서 별도 테이블 에 minimize bloat.
- **Use `fillfactor=90`** 에 leave 공간 위한 HOT 업데이트합니다 것 avoid 인덱스 유지보수.
- **Avoid updating 색인된 열**—방지합니다 beneficial HOT 업데이트합니다.
- **파티션 에 의해 업데이트 패턴**—별도 자주 업데이트된 행 에서 a 다른 파티션 에서 안정적인 데이터.

### Insert-Heavy Workloads

- **Minimize 인덱스**—오직 create 무엇 you 쿼리; 모든 인덱스 slows inserts.
- **Use `COPY` 또는 multi-행 `INSERT`** instead of single-행 inserts.
- **UNLOGGED 테이블** 위한 rebuildable staging 데이터—much faster 씁니다.
- **Defer 인덱스 생성** 위한 bulk 로드합니다—>drop 인덱스, load 데이터, recreate 인덱스.
- **파티션 에 의해 시간/해시** 에 distribute load. **TimescaleDB** 자동화합니다 분할 및 압축 of insert-heavy 데이터.
- **Use a natural 키 위한 primary 키** 그러한 처럼 a (타임스탬프, device_id) 만약 enforcing 전역 uniqueness is 중요한 많은 insert-heavy 테이블 don't need a primary 키 에서 모든.
- 만약 you do need a surrogate 키, **Prefer `BIGINT GENERATED ALWAYS AS IDENTITY` over `UUID`**.

### Upsert-Friendly 설계

- **필요합니다 고유한 인덱스** 에 conflict target 열—`ON CONFLICT (col1, col2)` needs exact 일치하는 고유한 인덱스 (부분 인덱스 don't work).
- **Use `EXCLUDED.column`** 에 참조 would-be-inserted 값; 오직 업데이트 열 것 actually 변경된 에 reduce write overhead.
- **`DO NOTHING` faster** 보다 `DO UPDATE` 때 아니요 actual 업데이트 필요한.

### Safe 스키마 Evolution

- **Transactional DDL**: most DDL 작업 can run 에서 transactions 및 be 롤백된—`BEGIN; ALTER TABLE...; ROLLBACK;` 위한 safe 테스트.
- **Concurrent 인덱스 생성**: `CREATE INDEX CONCURRENTLY` avoids 차단 씁니다 그러나 can't run 에서 transactions.
- **휘발성 defaults cause rewrites**: adding `NOT NULL` 열 와 함께 휘발성 defaults (e.g., `now()`, `gen_random_uuid()`) rewrites entire 테이블. Non-휘발성 defaults are fast.
- **Drop constraints 이전 열**: `ALTER TABLE DROP CONSTRAINT` then `DROP COLUMN` 에 avoid 종속성 이슈.
- **함수 signature 변경합니다**: `CREATE OR REPLACE` 와 함께 다른 인수 생성합니다 overloads, not replacements. DROP 오래된 버전 만약 아니요 overload 원하는.

## 생성된 열

- `... GENERATED ALWAYS AS (<expr>) STORED` 위한 계산된, indexable 필드. PG18+ adds `VIRTUAL` 열 (계산된 에 읽은, not 저장됨).

## Extensions

- **`pgcrypto`**: `crypt()` 위한 password 해싱.
- **`uuid-ossp`**: alternative UUID 함수; prefer `pgcrypto` 위한 새로운 projects.
- **`pg_trgm`**: fuzzy text search 와 함께 `%` 운영자, `similarity()` 함수. 인덱스 와 함께 GIN 위한 `LIKE '%pattern%'` acceleration.
- **`citext`**: case-insensitive text 유형. Prefer 표현식 인덱스 에 `LOWER(col)` 하지 않는 한 you need case-insensitive constraints.
- **`btree_gin`/`btree_gist`**: enable 혼합된-유형 인덱스 (e.g., GIN 인덱스 에 둘 다 JSONB 및 text 열).
- **`hstore`**: 키-값 쌍; 대부분 superseded 에 의해 JSONB 그러나 useful 위한 간단한 string 매핑.
- **`timescaledb`**: 필수 위한 시간-시리즈—자동화된 분할, retention, 압축, continuous 집계합니다.
- **`postgis`**: 포괄적인 geospatial 지원 beyond 기본 geometric 유형—필수 위한 위치-based 애플리케이션.
- **`pgvector`**: vector similarity search 위한 embeddings.
- **`pgaudit`**: audit 로깅 위한 모든 데이터베이스 activity.

## JSONB Guidance

- Prefer `JSONB` 와 함께 **GIN** 인덱스.
- default: `CREATE INDEX ON tbl USING GIN (jsonb_col);` → accelerates:
  - **Containment** `jsonb_col @> '{"k":"v"}'`
  - **키 existence** `jsonb_col ? 'k'`, **어떤/모든 키** `?\|`, `?&`
  - **경로 containment** 에 nested docs
  - **Disjunction** `jsonb_col @> ANY(ARRAY['{"status":"active"}', '{"status":"pending"}'])`
- Heavy `@>` workloads: consider opclass `jsonb_path_ops` 위한 smaller/faster containment-오직 인덱스:
  - `CREATE INDEX ON tbl USING GIN (jsonb_col jsonb_path_ops);`
  - **Trade-꺼짐**: loses 지원 위한 키 existence (`?`, `?|`, `?&`) 쿼리—오직 지원합니다 containment (`@>`)
- Equality/범위 에 a 특정 scalar 분야: extract 및 인덱스 와 함께 B-트리 (생성된 열 또는 표현식):
  - `ALTER TABLE tbl ADD COLUMN price INT GENERATED ALWAYS AS ((jsonb_col->>'price')::INT) STORED;`
  - `CREATE INDEX ON tbl (price);`
  - Prefer 쿼리 같은 `WHERE price BETWEEN 100 AND 500` (uses B-트리) over `WHERE (jsonb_col->>'price')::INT BETWEEN 100 AND 500` 없이 인덱스.
- 배열 내부 JSONB: use GIN + `@>` 위한 containment (e.g., 태그합니다). Consider `jsonb_path_ops` 만약 오직 doing containment.
- Keep 핵심 relations 에서 테이블; use JSONB 위한 선택적/가변 속성.
- Use constraints 에 limit 허용된 JSONB 값 에서 a 열 e.g. `config JSONB NOT NULL CHECK(jsonb_typeof(config) = 'object')`


## 예제

### 사용자

```sql
CREATE TABLE users (
  user_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE UNIQUE INDEX ON users (LOWER(email));
CREATE INDEX ON users (created_at);
```

### 정렬합니다

```sql
CREATE TABLE orders (
  order_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(user_id),
  status TEXT NOT NULL DEFAULT 'PENDING' CHECK (status IN ('PENDING','PAID','CANCELED')),
  total NUMERIC(10,2) NOT NULL CHECK (total > 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX ON orders (user_id);
CREATE INDEX ON orders (created_at);
```

### JSONB

```sql
CREATE TABLE profiles (
  user_id BIGINT PRIMARY KEY REFERENCES users(user_id),
  attrs JSONB NOT NULL DEFAULT '{}',
  theme TEXT GENERATED ALWAYS AS (attrs->>'theme') STORED
);
CREATE INDEX profiles_attrs_gin ON profiles USING GIN (attrs);
```
